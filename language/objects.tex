\secrel{Объекты, классы и наследование}

В Smalltalk все является объектом. В языке нет способа создать сущность, 
которая не является объектом. Среди основных компьютерных языков это 
единообразие в Smalltalk конкурирует, возможно, только с LISP, и, 
как и в LISP, единообразие создает и простоту, и мощь языка.

Объект обладает несколькими характеристиками (рисунок 1.1). Каждый объект 
содержит небольшой объем памяти, доступный только этому объекту. То есть 
ни один объект не может читать или изменять значения памяти в другом 
объекте. Конечно, поскольку всё в системе должно быть объектом, память 
объекта может содержать только ссылки на другие объекты. Мы обсудим 
это более подробно позже.

\fig{language/fig_1_1.png}{height=\textheight}

Все действия в системе \st\ производятся путем передачи сообщений. 
Сообщение\ --- это запрос у объекта выполнения какой-либо операции. Оно 
может содержать некоторые значения в качестве аргументов, которые будут 
использоваться как параметры при при выполнении запрошенной операции. 
Существует два способа рассматривать эту операцию передачи сообщения. 
Во-первых, передача сообщения соответствует вызову подпрограммы на обычном 
процедурном языке, таком как Паскаль. Это верно в том смысле, что работа 
отправителя останавливается до тех пор, пока получатель не выдаст результат.
\note{\st\ использует синхронные сообщения, поэтому отличия видны слабо, и часто возникают споры, чем сообщение отличается от вызова метода;
в этом смысле \st\ является вырожденным случаем, а наиболее явно это отличие видно в акторной модели \ref{actor}:
\emph{посылка сообщения не передает управление получателю}}
Затем результат возвращается отправителю, который продолжает выполнение 
с точки вызова. Однако сообщения могут создаваться динамически во время 
выполнения, и отношения между отправителем и получателем сообщения, как 
правило, гораздо более свободные, чем статические отношения между 
вызывающим и вызываемым в обычном языке программирования.

В реальном мире каждый объект индивидуален; однако каждый из них обладает 
общими характеристиками с другими подобными объектами. Например, в мешке 
яблок каждое яблоко отличается от всех других. Все же определенные заявления 
могут быть сделаны относительно всех яблок; например, все они будут 
пахнуть одинаково и иметь определенный вкус, все они могут быть использованы 
для выпечки пирогов одинаковым образом, и так далее. Этот процесс называется 
\term{классификацией}. То есть мы можем рассматривать яблоко как отдельный элемент 
или как \term{экземпляр} определенного \term{класса} (или категории) объектов. давайте 
обозначим класс всех яблок через \class{Apple}, заглавная буква и шрифт обозначает 
тот факт, что мы говорим о классе, а не об отдельном объекте.

Экземпляры класса \class{Orange} во многом отличаются от яблок и поэтому заслуживают 
отдельной категории. Но они также имеют много общих характеристик с яблоками. 
Таким образом, мы можем создать новый класс \class{Fruit}, который будет использоваться, 
когда мы хотим описать характеристики, общие для яблок и апельсинов. Класс 
\class{Fruit} включает в себя классы \class{Apple} и \class{Orange}. Таким образом, мы говорим, 
что \class{Fruit}\ --- это \term{суперкласс} \class{Apple} и \class{Orange}, а \class{Apple} и \class{Orange}, в свою 
очередь, являются \term{подклассами} \class{Fruit}.

Наконец, мы можем сделать еще один шаг этого анализа, сделав \class{Fruit} подклассом 
более универсальной категории, которую мы можем назвать \class{Object}. Таким образом, 
у нас есть иерархия категорий для объектов, расширяющаяся от базового класса 
\class{Object}, членом которого является все, вплоть до все более и более конкретных 
классов, пока мы не достигнем самого отдельного объекта.

Такая же ситуация имеет место в отношении всех сущностей в \st. То есть 
каждый объект является членом некоторого класса. За исключением класса \class{Object}, 
этот класс, в свою очередь, будет подклассом некоторого более крупного класса, 
который, в свою очередь, может быть частью другого класса, вплоть до одного 
класса \class{Object}, членом которого является каждый объект. Существует естественная 
древовидная структура (рисунок 1.2), которая иллюстрирует эту иерархию классов. 
Как мы уже делали, мы будем обозначать имена классов, используя первую заглавную 
букву, и обозначая имена объектов без использования заглавных букв. Так, 
например, число 7 является экземпляром класса \class{Integer}, как и число 8. Хотя 
7 и 8 являются различными объектами, они имеют некоторые общие характеристики 
в силу того, что они являются экземплярами одного и того же класса. Например, 
7 и 8 ответят на сообщение «+» целочисленным аргументом, выполнив сложение 
целых чисел. \class{Integer}\ --- это подкласс большего класса \class{Number}. Существуют и 
другие подклассы \class{Number}, например, \class{Float}, значения которых, например, 
3.1415926, являются его экземплярами. \class{Number} --- это подкласс \class{Magnitude} (класс, 
который будет обсуждаться позже), который, наконец, является подклассом \class{Object}.

\fig{language/fig_1_2.png}{height=.6\textheight}

\term{Поведение} объекта в ответ на конкретное сообщение определяется классом этого объекта. 
Например, 7 и 8 будут отвечать на сообщение «+» одинаково, потому что они оба 
являются экземплярами класса \class{Integer}. Список операторов, которые определяют, 
как экземпляр некоторого класса будет реагировать на сообщение, называется \term{методом}
для этого сообщения. Например, в классе \class{Integer} есть метод, связанный с 
сообщением «+». Весь набор сообщений, связанных с классом, называется \term{протоколом}
для этого класса. Класс \class{Integer} содержит в своем протоколе, например, сообщения 
для +, -, * и так далее. В \st\ протокол предоставляется как часть определения 
класса. Синтаксис определений классов будет описан в следующем разделе. 
Невозможно предоставить метод для отдельного объекта; каждый объект должен 
быть связан с некоторым классом, и поведение объекта в ответ на сообщения будет 
продиктовано методами, связанными с этим классом.

Если объект является экземпляром определенного класса, ясно, как будут использоваться 
методы, связанные с этим классом, но как насчет методов, связанных с суперклассами? 
Ответ в том, что любой метод, связанный с суперклассом, \term{наследуется} классом. 
Пример поможет прояснить эту концепцию. При отправке на номер сообщение \var{exp}
означает «вернуть значение $e$ (приблизительно 2,71828..), в степени указанного 
значения». Таким образом, \verb|2 exp| дает $e^2$, или приблизительно 7,38906. Теперь 
описание класса для \class{Integer} не предоставляет метод для сообщения \var{exp}, поэтому, 
когда система Little Smalltalk пытается найти связанный метод для сообщения 
\var{exp} в протоколе класса \class{Integer}, она не находит его. Таким образом, система 
\st\ затем анализирует протокол, связанный с непосредственным 
суперклассом \class{Integer}, а именно \class{Number}. Там, в протоколе для \class{Number}, она находит 
метод и выполняет его. Таким образом, мы говорим, что метод для \var{exp} \term{наследуется}
классом \class{Integer} из класса \class{Number}.
В \class{Number} метод, связанный с сообщением \var{exp}, выглядит следующим образом:
\begin{lstlisting}
    ^ self asFloat exp
\end{lstlisting}

Мы объясним синтаксис более подробно позже; на данный момент мы можем перевести 
этот код как «создать экземпляр \class{Float} с вашим значением (\verb|self asFloat|) и 
отправить этому объекту сообщение \var{exp}, запрашивающее $e$, возведенное в степень 
его значения. Возвратить\note{стрелка вверх $\wedge$ или $\uparrow$ указывает возвращаемое значение}
ответ на это сообщение". Таким образом, сообщение \var{asFloat} передается исходному 
целому числу, скажем, 2. Выполняется метод, связанный с этим сообщением, в 
результате чего получается значение с плавающей запятой 2.0. Сообщение \var{exp} 
затем передается этому значению. Это то же сообщение, которое первоначально 
было передано в целое число 2, только теперь класс получателя\ --- \class{Float}, 
а не \class{Integer}.

На рисунке 1.3 показана иерархия, представляющая несколько классов, включая числа. 
Как мы уже видели, метод для сообщения exp определен в классах \class{Number} и \class{Float}. 
Поиск метода начинается с класса объекта, а затем, при необходимости, проходит 
через различные суперклассы (по \term{цепочке наследования}). Если в сообщении \var{exp} 
дано значение с плавающей запятой, будет выполняться метод в классе \class{Float}, 
а не метод в классе \class{Number}. Таким образом, говорят, что метод для \var{exp} в \class{Float} 
\term{переопределяет} метод в классе \class{Number}.

\fig{language/fig_1_3.png}{height=.6\textheight}

Такие классы, как \class{Number} и \class{Magnitude}, которые обычно не имеют явных экземпляров, 
называются \term{абстрактными классами}. Абстрактные суперклассы важны для 
обеспечения того, чтобы экземпляры различных классов, такие как целые числа 
и числа с плавающей точкой, отвечали аналогичным образом в обычных ситуациях. 
Кроме того, устраняя необходимость дублировать методы для сообщений в 
суперклассе, они уменьшают размер описаний, необходимых для получения 
желаемого поведения.
