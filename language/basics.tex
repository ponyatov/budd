\secrel{Основы}\secdown

Эта глава знакомит с основными понятиями языка Smalltalk; а именно объект, метод, класс, наследование и переопределение.

\bigskip

Традиционной моделью, описывающей поведение компьютера, выполняющего программу, 
является модель состояния процесса, или модель «сортировщика». В этом 
представлении компьютер является диспетчером данных, который следует некоторому 
блоку инструкций, блуждает по памяти, извлекает значения из различных слотов 
(адресов памяти), преобразует их каким-либо образом, и передает результаты 
обратно в другие слоты. Изучая значения в слотах, можно определить состояние 
машины или результаты, полученные вычислением. Хотя это может быть более или 
менее точная картина того, что происходит в компьютере, это мало помогает нам 
понять, как решать проблемы с помощью компьютера, и это, конечно, не те способы, 
которыми думают большинство людей решающих проблемы (за исключением сортировщиков и почтальонов).

Давайте рассмотрим реалистичную ситуацию, а затем посмотрим, как можно заставить 
компьютер более точно моделировать методы, которые люди используют для решения 
проблем в повседневной жизни. Предположим, я хочу послать цветы моей бабушке 
на день рождения. Она живет далеко в городе за много миль от меня. Задача 
достаточно проста для выполнения; Я просто иду к местному флористу, описываю 
виды и количество цветов, которые я хочу отправить, и я могу быть уверен, 
что они будут доставлены автоматически. Если я проведу расследование, я, 
вероятно, обнаружу, что мой флорист отправляет сообщение с описанием моего 
заказа другому флористу в городе моей бабушки. Тот флорист тогда составляет 
букет и доставляет цветы. Я мог бы спросить, чтобы узнать, как цветочный 
магазин в городе моей бабушки покупает цветы и, возможно, узнал, что они 
получены от оптового торговца цветами. Если я продолжу настаивать, я даже 
смогу проследить всю цепочку до фермера, который выращивает цветы, и узнать, 
какие запросы были сделаны членами цепочки, чтобы получить желаемый результат от каждого.

Важным моментом, однако, является то, что мне не нужно, да и вообще, 
я не хочу знать, как будет выполняться моя простая директива 
«отправить цветы моей бабушке». В реальной жизни мы называем этот 
процесс \term{делегирование полномочий}. В информатике это называется 
\term{абстракция} или \term{сокрытие информации}. В основе этих терминов лежит 
одно и то же. Есть ресурс (флорист, файловый сервер), который я хочу 
использовать. Чтобы общаться, я должен знать команды, на которые будет 
реагировать ресурс (отправить цветы моей бабушке, вернуть копию файла 
с именем "chapеer!"). Скорее всего, шаги, которые должен предпринять 
ресурс, чтобы ответить на мой запрос, гораздо более сложны, чем я 
понимаю, но мне нет смысла знать подробности того, как реализуется 
моя директива, до тех пор, пока ответ (доставка цветов, получение 
копии моего файла) четко определено и предсказуемо.

\term{Объектно-ориентированная} модель решения проблем рассматривает компьютер
способом, очень близким к такому подходу. Действительно, многие люди, 
которые не имеют никакого образования в области информатики, и не знают, 
как работает компьютер, находят объектно-ориенти\-рован\-ную модель решения 
проблем вполне естественной. Удивительно, однако, что многие люди, 
имеющие традиционный опыт программирования, изначально думают, что в 
концепции объекта есть что-то странное. Представление о том, что число «7» 
является объектом, а «+» --- это запрос на сложение, может поначалу 
показаться странным. Но вскоре единообразие, мощь и гибкость, которые 
метафора объект/сообщение привносит в решение проблемы, делает эту 
интерпретацию так же естественной.

Вселенная \st\ населена \term{объектами}. В моем примере с цветами я являюсь объектом, 
а цветочный магазин (или флорист в нем)\ --- другим объектом. Действия 
инициируются путем отправки \term{сообщений}\ (запросов) между объектами. Я передал 
просьбу «отправить цветы моей бабушке» флористу-объекту. Реакция \term{получателя}
моего сообщения состоит в том, чтобы выполнить некоторую последовательность 
действий или \term{метод}, чтобы удовлетворить мой запрос. Может быть, получатель 
сможет немедленно удовлетворить мой запрос. С другой стороны, чтобы удовлетворить 
мои потребности, получателю, возможно, придется передавать другие сообщения 
еще большему количеству объектов (например, сообщение, которое мой флорист 
отправляет флористу в городе моей бабушки, или команду на дисковод). Кроме 
того, существует явный ответ (например, квитанция или код результата), 
возвращенный непосредственно мне. Дэн Ингаллс описывает философию \st\ (Байт 81):

\begin{quote}
    Вместо того, чтобы обрабатывать структуры данных, которые насилуют и грабят 
    процессор, мы имеем вселенную объектов с хорошим поведением, которые вежливо 
    просят друг друга выполнить их различные желания.
\end{quote}
    
Такие антропоморфные точки зрения распространены среди \st-программистов. 
В последующих главах мы увидим, как язык Smalltalk воплощает этот 
объектно-ориентированный взгляд на программирование. Описывая решение 
нескольких проблем в \st, мы надеемся показать, как объектно-ориентированная 
модель помогает в создании больших программных систем, и помогает в решении 
многих проблем с использованием компьютера.

\input{language/objects}

\input{language/backread}

\secly{Упражнения}

\begin{enumerate}

\item Определите следующие термины:

\noindent\begin{tabular}{l l l}
объект&
сообщение&
получатель\\
метод&
протокол&
класс\\
подкласс&
суперкласс&
наследование\\
переопределение&
абстрактный суперкласс\\
\end{tabular}

\item Приведите пример иерархии из повседневной жизни. Перечислите свойства, 
которые можно найти на каждом уровне, и выделите те, которые находятся на 
более низких уровнях, но не на более высоких уровнях.

\item Прочитайте о механизме классов в Simula (DaW 72) (BirtwistIe 73). 
Сравните и сопоставьте это с механизмом классов \st

\item В реальном мире объекты часто классифицируются ортогональными способами, 
а не в древовидной иерархии Smalltalk. Например, белоголовый орлан и кондор 
являются хищными птицами, но одна\ --- это североамериканская птица, а 
другая\ --- южноамериканская птица. Робин также североамериканская птица, 
но не хищная. Эти две отличительные характеристики являются ортогональными 
в том смысле, что ни одна из них не может быть логически названа надмножеством 
другой. Таким образом. навязывание классификации в древовидную структуру 
является неестественным, неэффективным или и тем, и другим. \\
Как можно классифицировать объекты Smalltalk ортогональными способами? Какие 
проблемы это создает для механизма наследования? Как можно преодолеть эти проблемы?

\end{enumerate}

\secup
