\secrel{Многозадачный язык}

Тот факт, что \st\ является многозадачным языком, создает ряд трудностей.
Можно подумать, что если реализация Smalltalk не разрешает несколько процессов,
даже если объекты могут сохраняться бесконечно долго, по крайней мере протокол
передачи сообщений будет демонстрировать поведение, подобное стеку. Например,
если сообщение \var{one} передается объекту \var{a}, а метод, связанный с этим
сообщением, передает второе сообщение \var{two} другому объекту \var{b}, то
второе сообщение должно сделать возврат до того, как отработает первое
сообщение. Таким образом, хранилище, возникающее как часть механизма передачи
сообщений, такое как хранилище для аргументов или временных переменных, может
быть выделено и освобождено стековым способом, подобным записям активации в
обычном языке.

К сожалению, это видение слишком упрощенное. Даже без многозадачности реализация
блоков вызывает проблемы. Для правильного выполнения блок должен иметь доступ к
среде (включая аргументы и временные переменные), в которой он был определен
(замыкание). Кроме того, блок может быть возвращен как результат обработки
сообщения, или назначен идентификатору и, таким образом, переживает сообщение, в
котором он был определен. Даже в случае одного процесса временные и аргументные
переменные не обязательно появляются и умирают в порядке стека.

Решение состоит в том, чтобы унифицированно применять алгоритмы диспетчера
памяти к тем объектам, соответствующим значениям, которые может видеть
пользователь, таким как идентификаторы, а также к внутренне сгенерированным
объектам, таким как те, которые соответствуют традиционным записям активации.
Когда сообщение должно быть отправлено, создается объект класса \class{Context}.
Контекст (рисунок 11.3)\ --- это объект похожий на массив, который указывает на
получателя сообщения, и на объекты-аргументы, переданные вместе с сообщением.
Контекст также предоставляет пространство для любых временных идентификаторов
или внутренних параметров (например, для блоков), которые понадобятся сообщению.

\fig{implement/fig_11_3.png}{height=.75\textheight}

Затем производится поиск описаний классов, чтобы найти фрагмент байт-кода,
соответствующему методу, который обрабатывает сообщение. Как только байт-код
найден, создается объект второго типа, называемый \class{Interpreter}. Имя
\class{Interpreter} является несколько неправильным; лучше его можно было бы
назвать \class{ИнтерпретируемыйМетодГотовыйКИсполнению}. Экземпляры класса
\class{Interpreter} указывают на байт-код, который они будут выполнять, на
контекст, который они будут использовать во время выполнения, и на стек
интерпретатора, используемый виртуальной машиной, которая выполняет байт-код
(рисунок 11.4).

\fig{implement/fig_11_4.png}{height=\textheight}

Когда интерпретатор выполняет инструкцию байт-кода, которая вызывает отправку
нового сообщения, создается новый экземпляр интерпретатора, который связывается
с существующим интерпретатором, который в свою очередь становится неактивным,
пока не вернется ответ на сообщение:

\fig{implement/fig_11_x.png}{height=.2\textheight}

\class{Process}\ --- это просто указатель на активный интерпретатор. Поскольку
может быть много процессов, все активные процессы связаны друг с другом (рисунок
11.5). Структура обработчика процесса будет обсуждаться в главе 14.

\fig{implement/fig_11_5.png}{height=\textheight}
