\secrel{Отсутствие типов у идентификаторов}

В Algol-подобном языке, таком как Pascal, все идентификаторы должны иметь
объявленный тип, известный во время синтаксического анализа программы при
компиляции. Таким образом, поскольку области памяти отводятся отдельно, либо во
время загрузки, либо во время выполнения, необходимо выделять пространство
только для значений, поскольку информация о типе известна компилятору, и код
может быть сгенерирован соответствующим образом.

\fig{implement/val.png}{height=.12\textheight}

В динамическом языке, таком как Smalltalk, тип идентификатора обычно не может
быть определен во время анализа программы (или описания класса). Традиционное
решение состоит в том, чтобы с памятью для каждого идентификатора ассоциировать
небольшой тег, который указывает тип объекта, хранимого в поле значения.

\fig{implement/tagval.png}{height=.1\textheight}

В языках, где количество типов данных является фиксированным и относительно
небольшим (например, во многих реализациях Lisp), это поле тега может быть также
небольшим, например, восемь бит. В Smalltalk, с другой стороны, единственное
понятие, вообще сопоставимое с понятием типа, это класс объекта, указанный
идентификатором; количество различных классов, которые можно определить,
практически безгранично. К счастью, для каждого класса существует уникальный
объект, содержащий информацию о классе, а именно объект класса. Таким образом,
тип каждого объект в системе Little Smalltalk может быть помечен указателем на
соответствующий объект класса.

\fig{implement/classval.png}{height=.12\textheight}

Чтобы определить, подходит ли какая-либо операция (сообщение) для какого-либо
объекта, система использует указатель класса для анализа класса (и, через другой
указатель в объекте класса, любых суперклассов) при поиске подходящего метода. В
следующей главе будет более подробно объяснена внутренняя структура объектов
Little Smalltalk.
